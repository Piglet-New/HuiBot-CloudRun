import os, logging, asyncio, threading, re, unicodedata
from datetime import datetime, timedelta
from flask import Flask, request, jsonify
from typing import Optional, Tuple

from telegram import Update
from telegram.ext import Application, CommandHandler, MessageHandler, ContextTypes, filters

from db_sqlite import (
    init_db, ensure_schema, cfg_get, cfg_set,
    get_all, exec_sql, insert_and_get_id
)

app = Flask(__name__)
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger("huibot")

BOT_TOKEN = (os.getenv("TELEGRAM_TOKEN") or os.getenv("BOT_TOKEN") or "").strip()
WEBHOOK_SECRET = os.getenv("WEBHOOK_SECRET", "").strip()
ADMIN_CHAT_ID = int(os.getenv("ADMIN_CHAT_ID", "0"))

ISO_FMT = "%Y-%m-%d"

def strip_accents(s: str) -> str:
    return ''.join(c for c in unicodedata.normalize('NFKD', s) if not unicodedata.combining(c))

def parse_iso(s: str) -> datetime:
    if hasattr(s, "year"):
        return datetime(s.year, s.month, s.day)
    return datetime.strptime(str(s), ISO_FMT)

def _smart_parse_dmy(s: str) -> Tuple[int,int,int]:
    s = s.strip().replace("/", "-")
    parts = s.split("-")
    if len(parts) != 3:
        raise ValueError(f"Kh√¥ng hi·ªÉu ng√†y: {s}")
    d, m, y = parts
    d, m, y = int(d), int(m), int(y)
    if y < 100:  y += 2000
    datetime(y, m, d)
    return d, m, y

def parse_user_date(s: str) -> datetime:
    d, m, y = _smart_parse_dmy(s)
    return datetime(y, m, d)

def to_iso_str(d: datetime) -> str:
    return d.strftime(ISO_FMT)

def to_user_str(d: datetime) -> str:
    return d.strftime("%d-%m-%Y")

def parse_money(text: str) -> int:
    s = str(text).strip().lower().replace(",", "").replace("_", "").replace(" ", "").replace(".", "")
    if s.isdigit():
        return int(s)
    try:
        if s.endswith("tr"): return int(float(s[:-2]) * 1_000_000)
        if s.endswith(("k","n")): return int(float(s[:-1]) * 1_000)
        if s.endswith(("m","t")): return int(float(s[:-1]) * 1_000_000)
        return int(float(s))
    except Exception:
        raise ValueError(f"Kh√¥ng hi·ªÉu gi√° tr·ªã ti·ªÅn: {text}")

def k_date(line, k: int) -> datetime:
    return parse_iso(line["start_date"]) + timedelta(days=(k-1)*int(line["period_days"]))

def roi_to_str(r: float) -> str:
    return f"{r*100:.2f}%"

def get_bids(line_id: int):
    rows = get_all("SELECT k, bid FROM rounds WHERE line_id=? ORDER BY k", (line_id,))
    return {int(r["k"]): int(r["bid"]) for r in rows}

def payout_at_k(line, bids: dict, k: int) -> int:
    M, N = int(line["contrib"]), int(line["legs"])
    T_k = int(bids.get(k, 0))
    D   = int(round(M * float(line.get("thau_rate", 0)) / 100.0))
    return (k-1)*M + (N - k)*(M - T_k) - D

def paid_so_far_if_win_at_k(bids: dict, M: int, k: int) -> int:
    return sum((M - int(bids.get(j, 0))) for j in range(1, k))

def compute_profit_var(line, k: int, bids: dict):
    M = int(line["contrib"])
    po = payout_at_k(line, bids, k)
    paid = paid_so_far_if_win_at_k(bids, M, k)
    base = paid if paid > 0 else M
    profit = po - paid
    roi = profit / base if base else 0.0
    return profit, roi, po, paid

def best_k_var(line, bids: dict, metric="roi"):
    bestk, bestkey, bestinfo = 1, -1e18, None
    for kk in range(1, int(line["legs"]) + 1):
        p, r, po, paid = compute_profit_var(line, kk, bids)
        key = r if metric == "roi" else p
        if key > bestkey:
            bestk, bestkey, bestinfo = kk, key, (p, r, po, paid)
    return bestk, bestinfo

def is_finished(line) -> bool:
    if line.get("status") == "CLOSED": return True
    last = k_date(line, int(line["legs"])).date()
    return datetime.now().date() >= last

init_db(); ensure_schema()

app_state = {"loop": None, "application": None, "started": False}

async def notify_admin(text: str):
    if ADMIN_CHAT_ID and app_state.get("application"):
        try:
            await app_state["application"].bot.send_message(chat_id=ADMIN_CHAT_ID, text=text[:4000])
        except Exception:
            logger.exception("notify_admin failed")

async def cmd_start(upd: Update, ctx: ContextTypes.DEFAULT_TYPE):
    await upd.message.reply_text("üëã H·ª•i Bot Cloud Run ƒë√£ s·∫µn s√†ng. G√µ /lenh ƒë·ªÉ xem l·ªánh.")

def _int_like(s: str) -> int:
    m = re.search(r"-?\d+", s or "")
    if not m: raise ValueError(f"Kh√¥ng ph·∫£i s·ªë: {s}")
    return int(m.group(0))

async def cmd_lenh(upd: Update, ctx: ContextTypes.DEFAULT_TYPE):
    await upd.message.reply_text(
        "üåü L·ªÜNH CH√çNH (DD-MM-YYYY):\n"
        "/tao <t√™n> <tu·∫ßn|th√°ng> <DD-MM-YYYY> <s·ªë_ch√¢n> <m·ªánh_gi√°> <s√†n_%> <tr·∫ßn_%> <ƒë·∫ßu_th·∫£o_%>\n"
        "/tham <m√£_d√¢y> <k·ª≥> <s·ªë_ti·ªÅn_thƒÉm> [DD-MM-YYYY]\n"
        "/hen <m√£_d√¢y> <HH:MM>\n"
        "/danhsach\n/tomtat <m√£_d√¢y>\n/hottot <m√£_d√¢y> [Roi%|L√£i]\n/dong <m√£_d√¢y>\n/baocao [chat_id]"
    )

async def cmd_setreport(upd: Update, ctx: ContextTypes.DEFAULT_TYPE):
    cfg = cfg_get("bot_cfg", {}) or {}
    if ctx.args:
        try: cid = int(ctx.args[0])
        except Exception: return await upd.message.reply_text("‚ùå `chat_id` kh√¥ng h·ª£p l·ªá.")
    else:
        cid = upd.effective_chat.id
    cfg["report_chat_id"] = cid
    cfg_set("bot_cfg", cfg)
    await upd.message.reply_text(f"‚úÖ ƒê√£ l∆∞u n∆°i nh·∫≠n b√°o c√°o/nh·∫Øc: {cid}")

async def _create_line_and_reply(upd: Update, name, kind, start_user, legs, contrib, base_rate, cap_rate, thau_rate):
    kind_l = str(kind).lower()
    period_days = 7 if kind_l in ["tuan","tu·∫ßn","t","week","weekly"] else 30
    start_dt  = parse_user_date(start_user)
    start_iso = to_iso_str(start_dt)
    legs      = int(legs)
    contrib_i = parse_money(contrib)
    base_rate = float(base_rate); cap_rate = float(cap_rate); thau_rate = float(thau_rate)
    if not (0 <= base_rate <= cap_rate <= 100): raise ValueError("s√†n% <= tr·∫ßn% v√† trong [0..100]")
    if not (0 <= thau_rate <= 100): raise ValueError("ƒë·∫ßu th·∫£o% trong [0..100]")

    line_id = insert_and_get_id(
        "INSERT INTO lines(name,period_days,start_date,legs,contrib,bid_type,bid_value,status,base_rate,cap_rate,thau_rate,remind_hour,remind_min,last_remind_iso) "
        "VALUES(?,?,?,?,?,'dynamic',0,'OPEN',?,?,?,8,0,NULL)",
        (name, period_days, start_iso, legs, contrib_i, base_rate, cap_rate, thau_rate)
    )

    await upd.message.reply_text(
        f"‚úÖ T·∫°o d√¢y #{line_id} ({name}) ‚Äî {'H·ª•i Tu·∫ßn' if period_days==7 else 'H·ª•i Th√°ng'}\n"
        f"‚Ä¢ M·ªü: {to_user_str(start_dt)} ¬∑ Ch√¢n: {legs} ¬∑ M·ªánh gi√°: {contrib_i:,} VND\n"
        f"‚Ä¢ S√†n {base_rate:.2f}% ¬∑ Tr·∫ßn {cap_rate:.2f}% ¬∑ ƒê·∫ßu th·∫£o {thau_rate:.2f}% (tr√™n M)\n"
        f"‚è∞ Nh·∫Øc m·∫∑c ƒë·ªãnh: 08:00 (ƒë·ªïi b·∫±ng /hen {line_id} HH:MM)\n"
        f"‚û°Ô∏è Nh·∫≠p thƒÉm: /tham {line_id} <k·ª≥> <s·ªë_ti·ªÅn_thƒÉm> [DD-MM-YYYY]"
    )

async def cmd_tao(upd: Update, ctx: ContextTypes.DEFAULT_TYPE):
    if len(ctx.args) < 8:
        return await upd.message.reply_text("‚ùóC√∫ ph√°p: /tao <t√™n> <tu·∫ßn|th√°ng> <DD-MM-YYYY> <s·ªë_ch√¢n> <m·ªánh_gi√°> <s√†n_%> <tr·∫ßn_%> <ƒë·∫ßu_th·∫£o_%>")
    try:
        await _create_line_and_reply(upd, *ctx.args[:8])
    except Exception as e:
        logger.exception("cmd_tao error: %s", e)
        await upd.message.reply_text(f"‚ö†Ô∏è L·ªói: {e}")

async def _save_tham_msg(upd: Update, line_id: int, k: int, bid: int, rdate_iso: Optional[str]):
    rows = get_all("SELECT * FROM lines WHERE id=?", (line_id,))
    if not rows:  return await upd.message.reply_text("‚ùå Kh√¥ng t√¨m th·∫•y d√¢y.")
    line = rows[0]
    if not (1 <= k <= int(line["legs"])): return await upd.message.reply_text(f"‚ùå K·ª≥ h·ª£p l·ªá 1..{line['legs']}.")
    M = int(line["contrib"])
    min_bid = int(round(M * float(line.get("base_rate", 0)) / 100.0))
    max_bid = int(round(M * float(line.get("cap_rate", 100)) / 100.0))
    if bid < min_bid or bid > max_bid:
        return await upd.message.reply_text(
            f"‚ùå ThƒÉm ph·∫£i trong [{min_bid:,} .. {max_bid:,}] VND "
            f"(S√†n {line['base_rate']}% ¬∑ Tr·∫ßn {line['cap_rate']}% ¬∑ M={M:,})"
        )

    exec_sql(
        "INSERT INTO rounds(line_id,k,bid,round_date) VALUES(?,?,?,?) "
        "ON CONFLICT(line_id,k) DO UPDATE SET bid=excluded.bid, round_date=excluded.round_date",
        (line_id, k, bid, rdate_iso)
    )
    await upd.message.reply_text(
        f"‚úÖ L∆∞u thƒÉm k·ª≥ {k} cho d√¢y #{line_id}: {bid:,} VND" + (f" ¬∑ ng√†y {to_user_str(parse_iso(rdate_iso))}" if rdate_iso else "")
    )

async def cmd_tham(upd: Update, ctx: ContextTypes.DEFAULT_TYPE):
    if len(ctx.args) < 3:
        return await upd.message.reply_text("‚ùóC√∫ ph√°p: /tham <m√£_d√¢y> <k·ª≥> <s·ªë_ti·ªÅn_thƒÉm> [DD-MM-YYYY]")
    try:
        line_id = int(ctx.args[0])
        k = int(ctx.args[1])
        bid = parse_money(ctx.args[2])
        rdate_iso = to_iso_str(parse_user_date(ctx.args[3])) if len(ctx.args) >= 4 else None
        await _save_tham_msg(upd, line_id, k, bid, rdate_iso)
    except Exception as e:
        logger.exception("cmd_tham error: %s", e)
        await upd.message.reply_text(f"‚ö†Ô∏è L·ªói: {e}")

async def cmd_hen(upd: Update, ctx: ContextTypes.DEFAULT_TYPE):
    if len(ctx.args) != 2:
        return await upd.message.reply_text("‚ùóC√∫ ph√°p: /hen <m√£_d√¢y> <HH:MM>  (VD: /hen 1 07:45)")
    try:
        line_id = int(ctx.args[0])
        hh, mm = ctx.args[1].split(":"); hh = int(hh); mm = int(mm)
        if not (0 <= hh <= 23 and 0 <= mm <= 59): raise ValueError("gi·ªù/ph√∫t kh√¥ng h·ª£p l·ªá")
    except Exception as e:
        return await upd.message.reply_text(f"‚ùå Tham s·ªë kh√¥ng h·ª£p l·ªá: {e}")
    rows = get_all("SELECT id FROM lines WHERE id=?", (line_id,))
    if not rows: return await upd.message.reply_text("‚ùå Kh√¥ng t√¨m th·∫•y d√¢y.")
    exec_sql("UPDATE lines SET remind_hour=?, remind_min=? WHERE id=?", (hh, mm, line_id))
    await upd.message.reply_text(f"‚úÖ ƒê√£ ƒë·∫∑t gi·ªù nh·∫Øc cho d√¢y #{line_id}: {hh:02d}:{mm:02d}")

def list_text() -> str:
    rows = get_all("SELECT id,name,period_days,start_date,legs,contrib,base_rate,cap_rate,thau_rate,status,remind_hour,remind_min FROM lines ORDER BY id DESC")
    if not rows: return "üìÇ Ch∆∞a c√≥ d√¢y n√†o."
    out = ["üìã **Danh s√°ch d√¢y**:"]
    for r in rows:
        kind = "Tu·∫ßn" if int(r["period_days"])==7 else "Th√°ng"
        out.append(
            f"‚Ä¢ #{r['id']} ¬∑ {r['name']} ¬∑ {kind} ¬∑ m·ªü {to_user_str(parse_iso(r['start_date']))} ¬∑ ch√¢n {r['legs']} ¬∑ M {int(r['contrib']):,} VND ¬∑ "
            f"s√†n {float(r['base_rate']):.2f}% ¬∑ tr·∫ßn {float(r['cap_rate']):.2f}% ¬∑ th·∫ßu {float(r['thau_rate']):.2f}% ¬∑ nh·∫Øc {int(r['remind_hour']):02d}:{int(r['remind_min']):02d} ¬∑ {r['status']}"
        )
    return "\n".join(out)

async def cmd_danhsach(upd: Update, ctx: ContextTypes.DEFAULT_TYPE):
    await upd.message.reply_text(list_text())

def load_line(line_id: int):
    rows = get_all("SELECT * FROM lines WHERE id=?", (line_id,))
    return rows[0] if rows else None

async def cmd_tomtat(upd: Update, ctx: ContextTypes.DEFAULT_TYPE):
    if not ctx.args: return await upd.message.reply_text("‚ùóC√∫ ph√°p: /tomtat <m√£_d√¢y>")
    try: line_id = int(ctx.args[0])
    except Exception: return await upd.message.reply_text("‚ùå m√£_d√¢y ph·∫£i l√† s·ªë.")
    line = load_line(line_id)
    if not line: return await upd.message.reply_text("‚ùå Kh√¥ng t√¨m th·∫•y d√¢y.")
    bids = get_bids(line_id)
    M, N = int(line["contrib"]), int(line["legs"])
    cfg_line = f"S√†n {float(line.get('base_rate',0)):.2f}% ¬∑ Tr·∫ßn {float(line.get('cap_rate',100)):.2f}% ¬∑ ƒê·∫ßu th·∫£o {float(line.get('thau_rate',0)):.2f}% (tr√™n M)"
    k_now = max(1, min(len(bids)+1, N))
    p, r, po, paid = compute_profit_var(line, k_now, bids)
    bestk, (bp, br, bpo, bpaid) = best_k_var(line, bids, metric="roi")
    msg = [
        f"üìå D√¢y #{line['id']} ¬∑ {line['name']} ¬∑ {'Tu·∫ßn' if int(line['period_days'])==7 else 'Th√°ng'}",
        f"‚Ä¢ M·ªü: {to_user_str(parse_iso(line['start_date']))} ¬∑ Ch√¢n: {N} ¬∑ M·ªánh gi√°/k·ª≥: {M:,} VND",
        f"‚Ä¢ {cfg_line} ¬∑ Nh·∫Øc {int(line.get('remind_hour',8)):02d}:{int(line.get('remind_min',0)):02d}",
        f"‚Ä¢ ThƒÉm: " + (", ".join([f"k{kk}:{int(b):,}" for kk,b in sorted(bids.items())]) if bids else "(ch∆∞a c√≥)"),
        f"‚Ä¢ K·ª≥ hi·ªán t·∫°i ∆∞·ªõc t√≠nh: {k_now} ¬∑ Payout: {po:,} ¬∑ ƒê√£ ƒë√≥ng: {paid:,} ‚Üí L√£i: {int(round(p)):,} (ROI {roi_to_str(r)})",
    ]
    best_line = f"‚≠ê ƒê·ªÅ xu·∫•t (ROI): k·ª≥ {bestk} ¬∑ ng√†y {to_user_str(k_date(line,bestk))} ¬∑ Payout {bpo:,} ¬∑ ƒê√£ ƒë√≥ng {bpaid:,} ¬∑ L√£i {int(round(bp)):,} ¬∑ ROI {roi_to_str(br)}"
    msg.append(best_line)
    if is_finished(line): msg.append("‚úÖ D√¢y ƒë√£ ƒë·∫øn h·∫°n ‚Äî /dong ƒë·ªÉ l∆∞u tr·ªØ.")
    await upd.message.reply_text("\n".join(msg))

async def cmd_hottot(upd: Update, ctx: ContextTypes.DEFAULT_TYPE):
    if len(ctx.args) < 1: return await upd.message.reply_text("‚ùóC√∫ ph√°p: /hottot <m√£_d√¢y> [Roi%|L√£i]")
    try: line_id = int(ctx.args[0])
    except Exception: return await upd.message.reply_text("‚ùå m√£_d√¢y ph·∫£i l√† s·ªë.")
    metric = "roi"
    if len(ctx.args) >= 2:
        raw = strip_accents(ctx.args[1].strip().lower().replace("%", ""))
        if raw in ("roi", "lai"): metric = raw
    line = load_line(line_id)
    if not line: return await upd.message.reply_text("‚ùå Kh√¥ng t√¨m th·∫•y d√¢y.")
    bids = get_bids(line_id)
    bestk, (bp, br, bpo, bpaid) = best_k_var(line, bids, metric=("roi" if metric=="roi" else "lai"))
    await upd.message.reply_text(
        f"üîé G·ª£i √Ω theo {'ROI%' if metric=='roi' else 'L√£i'}:\n"
        f"‚Ä¢ N√™n h·ªët k·ª≥: {bestk}\n"
        f"‚Ä¢ Ng√†y d·ª± ki·∫øn: {to_user_str(k_date(line,bestk))}\n"
        f"‚Ä¢ Payout k·ª≥ ƒë√≥: {bpo:,}\n"
        f"‚Ä¢ ƒê√£ ƒë√≥ng tr∆∞·ªõc ƒë√≥: {bpaid:,}\n"
        f"‚Ä¢ L√£i ∆∞·ªõc t√≠nh: {int(round(bp)):,} ‚Äî ROI: {roi_to_str(br)}"
    )

async def cmd_dong(upd: Update, ctx: ContextTypes.DEFAULT_TYPE):
    if not ctx.args: return await upd.message.reply_text("‚ùóC√∫ ph√°p: /dong <m√£_d√¢y>")
    try: line_id = int(ctx.args[0])
    except Exception: return await upd.message.reply_text("‚ùå m√£_d√¢y ph·∫£i l√† s·ªë.")
    exec_sql("UPDATE lines SET status='CLOSED' WHERE id=?", (line_id,))
    await upd.message.reply_text(f"üóÇÔ∏è ƒê√£ ƒë√≥ng & l∆∞u tr·ªØ d√¢y #{line_id}.")

async def cmd_huy(upd: Update, ctx: ContextTypes.DEFAULT_TYPE):
    await upd.message.reply_text("üõë Hu·ª∑ wizard. H√£y d√πng c√°c l·ªánh m·ªôt b∆∞·ªõc nh∆∞ /tao, /tham, /hen ...")

async def handle_text(upd: Update, ctx: ContextTypes.DEFAULT_TYPE):
    await upd.message.reply_text("üí° Vui l√≤ng d√πng l·ªánh: /tao, /tham, /hen, /danhsach, /tomtat, /hottot, /dong, /baocao")

def build_app():
    application = Application.builder().token(BOT_TOKEN).build()
    application.add_handler(CommandHandler("start",    cmd_start))
    application.add_handler(CommandHandler("lenh",     cmd_lenh))
    application.add_handler(CommandHandler("baocao",   cmd_setreport))
    application.add_handler(CommandHandler("tao",      cmd_tao))
    application.add_handler(CommandHandler("tham",     cmd_tham))
    application.add_handler(CommandHandler("hen",      cmd_hen))
    application.add_handler(CommandHandler("danhsach", cmd_danhsach))
    application.add_handler(CommandHandler("tomtat",   cmd_tomtat))
    application.add_handler(CommandHandler("hottot",   cmd_hottot))
    application.add_handler(CommandHandler("dong",     cmd_dong))
    application.add_handler(CommandHandler("huy",      cmd_huy))
    application.add_handler(MessageHandler(filters.TEXT & ~filters.COMMAND, handle_text))

    async def on_error(update, context):
        logger.exception("PTB error: %s", context.error)
        try:
            await notify_admin(f"‚ö†Ô∏è PTB error: {context.error}")
        except Exception:
            pass
    application.add_error_handler(on_error)
    return application

def run_bot_background():
    if getattr(run_bot_background, "_started", False):
        return
    if not BOT_TOKEN:
        logger.warning("BOT_TOKEN is empty; bot will not start.")
        return
    loop = asyncio.new_event_loop()
    app_state["loop"] = loop

    async def _runner():
        app_state["application"] = build_app()
        await app_state["application"].initialize()
        await app_state["application"].start()
        logger.info("Telegram application started")
        while True:
            await asyncio.sleep(3600)

    def _thread():
        asyncio.set_event_loop(loop)
        loop.create_task(_runner())
        loop.run_forever()

    t = threading.Thread(target=_thread, name="tg-bot", daemon=True)
    t.start()
    app_state["started"] = True
    run_bot_background._started = True

run_bot_background()

@app.get("/")
def root():
    return "ok", 200

@app.get("/health")
def health():
    return jsonify(status="ok"), 200

@app.post("/webhook")
def webhook():
    expected = WEBHOOK_SECRET or ""
    got = request.args.get("secret", "")
    if expected and got != expected:
        return "forbidden", 403

    if not app_state.get("application") or not app_state.get("loop"):
        return "bot not started", 503

    data = request.get_json(silent=True) or {}
    try:
        update = Update.de_json(data, app_state["application"].bot)
        fut = asyncio.run_coroutine_threadsafe(
            app_state["application"].process_update(update),
            app_state["loop"]
        )
        fut.result(timeout=10)
    except Exception as e:
        logger.exception("webhook error: %s", e)
    return "ok", 200

if __name__ == "__main__":
    port = int(os.environ.get("PORT", "8080"))
    app.run(host="0.0.0.0", port=port)
